<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue]]></title>
    <url>%2F2017%2F07%2F01%2FVue%2F</url>
    <content type="text"><![CDATA[简单却不失优雅，小巧而不乏大匠 VueVue 开发必备：vue，vue-router、vue-resource，webpack还有一个就是饿了么团队开发的一个移动端组件库：mint-ui 配置 webpack 一方面帮助我们转换 vue 文件和 ES6 语法，一方面简化开发流程 具体配置信息可以参考另一篇文章Webpack使用 指令v-model 绑定数据模型，和 ng-model 一样，绑定表单元素 v-text 类似于 innerText，解析文本 v-html 类似于 innerHTML，按照 HTML 方式解析，并不推荐，推荐使用组件 v-bind 给一些没有相应指令的属性或者自定义属性绑定数据 语法可简化：v-bind:id=”id” –&gt; :id=”id” v-if 可控制元素的隐藏和显示，值是一个布尔值 true 表示显示（false 直接删除页面元素） v-show 控制元素的隐藏和显示，值是一个布尔值 true 表示显示（false 作用 display为none） v-for 遍历输出 v-for=”(item, index) in items” 可遍历对象 v-on 为元素绑定事件 v-on:click=”事件名称” 可简化语法： @click=”事件名称” tips: 并没有v-class这个指令，但是可以通过v-bind来作用class属性，比较强大的是，可以传一个对象进去，属性名是类名，值是布尔值。用法与ng一样；还可以传一个数组进去，同时作用多个类名；数组内也可以传对象，决定是否作用类名 使用v-for的时候，遍历对象的话，可以写成v-for=&quot;(value, key, index) in items&quot;第一个表示值，第二个表示键，第三个表示索引。 在使用v-for的时候，会出现和ng一样的困扰，ng的解决方法是 track by $index 来确定唯一项，vue的解决方法就是，在循环生成的元素上绑定一个key属性，因为是自定义属性的缘故，所以要用v-bind:key=””来进行绑定，值可以写上索引，也可以根据需求写上后台数据中的id，反正只要是个唯一值就可以了。 组件 tips: 一些小技巧 所有的当前实例中的事件都写在 methods 这个属性中， methods:{&#39;名称&#39;:function(){}} 在 Vue 实例中的data是一个JSON，但是在组件的中的data是一个函数，这是为了让不同的组件实例能够拥有各自的数据。]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack使用]]></title>
    <url>%2F2016%2F11%2F20%2FWebpack%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前端资源模块化管理和打包工具 简单示例初始化项目1npm init -y 安装1npm install webpack -g 最简单的就是 webpack app.js bulid.js webpack默认支持es6语法 配置名字是固定的 webpack.config.js，就是一个普通的 node 模块 配置webpack.config.js12345678910111213141516module.exports = &#123; entry: '/app.js', // 打包的入口文件 output: &#123; path: __dirname + '/bin', // 打包文件存储的位置 filename: 'bulid.js' // 打包好的文件名 &#125;, modules: &#123; loaders: [&#123; test: /\.fileType$/, // 设置处理的文件类型，文件后缀名 loader: '' // 设置处理的 loader，中间用!隔开 &#125;] &#125;, plugins: [ ]&#125; 最好加上绝对路径，也就是 __dirname 启动1webpack 会自动执行 webpack.config.js 文件 处理CSS模块安装1npm install style-loader css-loader --save-dev 配置webpack.config.js12345678910111213module.exports = &#123; entry: './app.js', output: &#123; path: __dirname + '/bin', filename: 'bundle.js' &#125;, module: &#123; loaders: [&#123; test: /\.css$/, //配置后缀名 loader: 'style-loader!css-loader' // 顺序不能反，从右往左执行 &#125;] &#125;&#125; style-loader是把css代码插到网页中的style标签中。css-loader处理导入的url 处理 CSS 中的前缀(去除过期的前缀，添加私有前缀)安装1npm install autoprefixer-loader --save-dev 配置webpack.config.js1234loaders: [&#123; test: /\.css$/, loader: 'style-loader!css-loader!autoprefixer-loader'&#125;] 处理 less安装1npm install less-loader less --save-dev 配置webpack.config.js1234loaders: [&#123; test: /\.less$/, loader: 'style-loader!css-loader!autoprefixer-loader!less-loader'&#125;] 处理 scss安装1npm install sass-loader node-sass --save-dev 配置webpack.config.js1234loaders: [&#123; test: /\.scss$/, loader: 'style-loader!css-loader!autoprefixer-loader!sass-loader'&#125;] 处理文件 url-loader file-loader安装1npm install --save-dev url-loader file-loader 配置webpack.config.js1234loaders: [&#123; test: /\.(jpg|png|gif|eot|svg|ttf|woff|otf)$/, loader: 'url-loader?limit=20480'&#125;] 默认会进行编译，那么就限制一下，小于20k的时候再进行转码编译，大于20k就不转码编译但是不编译的话，就会依赖file-loader，必须下载 file-loader 实时打包，浏览器实时自动刷新 webpack-dev-server html-webpack-plugin 注意！！！！如果全局安装了webpack，那么webpack-dev-server是跑不起来的，最简单的解决方法就是本地安装webpack，或者就是配置全局的环境变量 浏览器实时自动刷新 webpack-dev-server 安装1npm install webpack-dev-server --save-dev 运行1webpack-dev-server --inline --hot --open --port 3000 可以在package.json中配置，用npm run的形式跑起来123"script": &#123; "dev" : "webpack-dev-server --inline --hot --open --port 3000"&#125; _注意_：webpack-dev-server 要安装成全局的，才可以在命令行中执行npm run dev 就可以执行 但是，npm run 的这种方式，又必须在本地安装 webpack npm install webpack –save-dev 参数 inline 自动刷新 hot 热加载 open 自动在浏览器中打开 port 指定端口 在内存中生成index.html，并且自动打包编译的文件(app.js中引用的文件) html-webpack-plugin 安装1npm install html-webpack-plugin --save-dev 配置webpack.config.js12345678910111213let htmlWebpackPlugin = require('html-webpack-plugin'); //引入modules: &#123;&#125;,plugins: [ new htmlWebpackPlugin(&#123; title: '页面的标题', // 生成的页面标题 filename: 'index.html', // 生成的文件名称 template: 'template.html' // 模板名称 &#125;)] ES6 转 ES5安装123npm install babel-core babel-loader babel-preset-es2015 --save-dev// 转换.vue文件中的ES6语法npm install babel-plugin-transform-runtime --save-dev 配置webpak.config.js12345678910111213141516171819var webpack = require('webpack') // 引入modules: &#123; loaders: [&#123; test: /\.js$/, exclude: /node_modules/, // 排除指定内容 loader: 'babel-loader' &#125;]&#125;,plugins: [ new webpack.LoaderOptionsPlugin(&#123; options: &#123; babel: &#123; presets: ['es2015'], plugins: ['transform-runtime'] //为了转换.vue中的es6的语法 &#125; &#125; &#125;) ]]]></content>
      <tags>
        <tag>构建工具</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于rem]]></title>
    <url>%2F2016%2F04%2F02%2F%E5%85%B3%E4%BA%8Erem%2F</url>
    <content type="text"><![CDATA[web app 之 rem 关于 remrem是什么？rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到rem大家一定会想起em单位em（font size of the element）是指相对于父元素的字体大小的单位它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。 rem –&gt; 相对于根元素em –&gt; 相对于父元素 em 相对单位 相对于父级元素设置的文字大小进行设置如果没有设置文字大小，就是默认 rem 也是相对单位，但是相对的却是根元素。网页中的根元素指的是html通过设置html的字体大小，就可以控制rem的大小 使用方式举一个简单的例子 123456html &#123; font-size: 20px;&#125;div &#123; width: 1rem; /* 等同于 width: 20px */&#125; 123456html &#123; font-size: 20px;&#125;div &#123; width: 5rem; /* 等同于 width: 20px */&#125; 从上面的两个例子可以看出来，rem的值完全就是根据根元素的字体大小的值来进行改变的那么只要在不同的屏幕中给html设置不同的字体大小便可以更改rem的值 那么，这个时候问题就来了。怎么计算出不同分辨率下font-size的值 首先假设我上面的页面设计稿给我时候是按照640的标准尺寸给我的，（当然这个尺寸肯定不一定是640，可以是320，或者480，又或是375）来看一组表格。 屏幕尺寸 html设置字体 元素宽度 rem 尺寸 页面显示 640 20px 200px 10rem 200px 480 15px 150px 10rem 150px 384 12px 120px 10rem 120px 320 10px 100px 10rem 100px 这个表格的表现出来的数字其实就已经很明显了。 比如：因为设计稿是640的，那么上面宽度为200px的元素，其页面显示的大小应该也是200px；那么在384的页面中，页面显示相同的元素，其宽度应该变成 200*(384/640) px； 384/640 = 0.6，384是640的0.6倍，所以384页面宽度下的font-size也等于640页面宽度下的0.6倍，这时384的font-size就等于12px。在不同设备的宽度计算方式以此类推。 总结一下其实 rem 这个东西对于移动端开发来说简直就是一个福音，因为在传统的移动端开发来说的话，各种方式都会有一定的弊端 流式布局的话通过百分比来定义宽度，但是高度的话往往是用px来定住，这个时候在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度还是和原来一样，十分不协调。 固定页面宽度的做法，虽然一定程度上解决了上面高度定死，宽度拉长的问题，但是在大屏幕的手机下，两边都是留白，不美观，并且在大屏幕下页面会特别小。 响应式的做法只能是针对小型的门户或者博客类网站会用，因为大网站用响应式的话工作量会特别大，并且难以维护。 设置viewport进行缩放的话，简单，粗暴，高效，以一个较小的屏幕为基准，缩放到一定程度。基本上可以满足适配的问题。 rem则是可以做到全设备，全尺寸的等比例适配。 根据屏幕宽度的不同，用js判断或者使用css3中的媒体查询设定不同屏幕宽度下根元素的字体大小。做到全设备的自适应。]]></content>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery插件开发]]></title>
    <url>%2F2016%2F03%2F15%2FjQuery%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[jQuery的插件开发流程 jQuery 插件开发根据《jQuery高级编程》的描述，jQuery插件开发方式主要有三种： 通过$.extend()来扩展jQuery通过$.fn 向jQuery添加新的方法通过$.widget()应用jQuery UI的部件工厂方式创建 第三种方式我并不是很了解，所以这里只介绍前两种方法 $.extend()使用这种方式来进行插件开发很简单，因为这就是相当于仅仅是在jQuery命名空间或者理解成jQuery身上添加了一个静态方法而已，直接通过$符号就可以调用。 123456$.extend(&#123; sayHi: function()&#123; console.log('Hello World!'); &#125;&#125;)$.sayHi(); 上面代码中，通过$.extend()向jQuery添加了一个sayHi函数，然后通过$直接调用。到此你可以认为我们已经完成了一个简单的jQuery插件了。 但这种方式无法利用jQuery强大的选择器带来的便利，要处理DOM元素以及将插件更好地运用于所选择的元素身上，还是需要使用第二种开发方式。我们使用的插件也大多是通过此种方式开发。 $.fn.extend()123$.fn.pluginName = function ()&#123; // 插件逻辑代码&#125; 基本上就是往$.fn上面添加一个方法，名字是我们的插件名称。然后我们的插件代码在这个方法里面展开。 在插件名字定义的这个函数内部，this指代的是我们在调用该插件时，用jQuery选择器选中的元素，一般是一个jQuery类型的集合。 支持链式调用123456$.fn.myPlugin = function() &#123; this.css('color', 'red'); return this.each(function() &#123; $(this).append(' ' + $(this).attr('href')); &#125;))&#125; 想要让开发的插件支持链式调用的话，其实很简单，只需要最后 return 一下即可 插件接收参数1234567891011$.fn.myPlugin = function(options)&#123; var defaults = &#123; 'color': 'red', 'fontSize': '12px' &#125;; var settings = $.extend(&#123;&#125;, defaults, options); return this.css(&#123; 'color': settings.color, 'fontSize': settings.fontSize &#125;);&#125; 一般来说，想要望插件里面传递自定义的参数，用的就是这种方法。defaluts 表示的是默认的参数，当用户没有传递向对应的自定义参数的时候，就使用默认的settings 的作用是将参数中的每一项拷贝到这个对象中，进行处理 面向对象的方式来开发插件前面的方式其实已经可以写出一个健壮灵活的插件了，但是要是写一个复杂的插件的话，代码量大，代码的组织就是一个问题，使用面向对象的方式来进行开发，会更灵活，可维护 12345678910111213141516171819202122var Beautifier = function(ele, opt) &#123; this.$element = ele, this.defaults = &#123; 'color': 'red', 'fontSize': '12px', 'textDecoration':'none' &#125;, this.options = $.extend(&#123;&#125;, this.defaults, opt)&#125;Beautifier.prototype = &#123; beautify: function() &#123; return this.$element.css(&#123; 'color': this.options.color, 'fontSize': this.options.fontSize, 'textDecoration': this.options.textDecoration &#125;); &#125;&#125;$.fn.myPlugin = function(options) &#123; var beautifier = new Beautifier(this, options); return beautifier.beautify();&#125; 将需要的重要变量定义到对象的属性上，函数变成对象的方法，当我们需要的时候通过对象来获取一来方便管理，二来不会影响外部命名空间，因为所有这些变量名还有方法名都是在对象内部。 闭包函数，防止命名冲突123456789101112131415161718192021222324;(function($, window, document, undefined) &#123; var Beautifier = function(ele, opt) &#123; this.$element = ele, this.defaults = &#123; 'color': 'red', 'fontSize': '12px', 'textDecoration': 'none' &#125;, this.options = $.extend(&#123;&#125;, this.defaults, opt) &#125; Beautifier.prototype = &#123; beautify: function() &#123; return this.$element.css(&#123; 'color': this.options.color, 'fontSize': this.options.fontSize, 'textDecoration': this.options.textDecoration &#125;); &#125; &#125; $.fn.myPlugin = function(options) &#123; var beautifier = new Beautifier(this, options); return beautifier.beautify(); &#125;&#125;)(jQuery, window, document); 这就是一个完整的插件开发流程。]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery的简单实现]]></title>
    <url>%2F2016%2F03%2F12%2FjQuery%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[对jQ的源码做了一些了解，在这里简单实现一下。 关于jQuery不可否认，jQuery的重要性，使用频率堪称前端程序员之最。正像作者所提出的口号一样：“Write Less, Do More”，写的更少，做的更多。 独特的链式语法，高效灵活的CSS选择器，便捷的插件扩展机制，强大的兼容性 tips：关于jQuery中的选择器引擎，是jQuery作者另外写的一个选择器引擎，这里不多做介绍，本篇文章利用H5新增的querySelectorAll来模拟jQuery中的Sizzle选择器引擎。 第一阶段模拟选择器引擎123function Sizzle(selector)&#123; return document.querySelectorAll(selector);&#125; Sizzle函数只是用来获取元素的方法，那么为了不影响其独立性和干净，所有方法和属性就不应该扔在Sizzle函数中。 定义函数，在函数内部调用Sizzle函数来获取到元素1234567891011121314151617 function Sizzle(selector)&#123; return document.querySelectorAll(selector); &#125; function IT(selector) &#123; var doms = Sizzle(selector); doms.a = function ()&#123; for (var i = 0; i &lt; this.length; i++) &#123; var dom = this[i]; console.log(dom); &#125; &#125; return doms; &#125; var doms = IT('div');doms.a(); 这样的话，会出现另一个问题，当获取多个页面元素的时候，因为a方法是定义在DOM元素下面的，那么获取多个元素的时候，就会创建多个a方法的内存空间，从而影响性能 将方法放在原型上，解决多个元素的时候，创建多个内存空间的问题123456789101112131415function Sizzle(selector)&#123; return document.querySelectorAll(selector);&#125;NodeList.prototype.a = function()&#123; for (var i = 0; i &lt; this.length; i++) &#123; var dom = this[i]; console.log(dom);&#125;&#125;function IT(selector)&#123; var doms = Sizzle(selector); return doms;&#125; doms是NodeList的实例。那么doms对象指向的原型就应该是NodeList函数的原型 这个时候，访问原型上的方法就可以避免创建多个内存空间的问题 但是NodeList是一个内置的对象，不应该进行污染，那么就自定义一个对象，将所有的方法放在自定义对象中 将方法放在自定义对象中12345678910111213141516function Sizzle(selector)&#123; return document.querySelectorAll(selector);&#125;function IT(selector) &#123; var doms = Sizzle(selector); var obj = &#123; a: function ()&#123; for (var i = 0; i &lt; this.length; i++) &#123; var dom = this[i]; console.log(dom); &#125; &#125; &#125; obj.elements = doms; return obj;&#125; 创建一个对象，让获取到的元素成为这个对象的一个属性，那么这些元素就可以访问到这个对象上面的所有方法，并且没有污染到内置的对象。 但是，这个时候，又回到了以前的一个问题，，每次调用 IT 函数的时候，又会创建单独的对象，方法就又指向了不同的内存空间。影响性能 将方法放在自定义的构造函数中123456789101112131415161718192021222324252627 function Sizzle(selector)&#123; return document.querySelectorAll(selector); &#125; function F()&#123; &#125; F.prototype = &#123; constructor: F, a: function ()&#123; for (var i = 0; i &lt; this.elements.length; i++) &#123; var dom = this.elements[i]; console.log(dom); &#125; &#125; &#125; function IT(selector) &#123; var doms = Sizzle(selector); var f = new F(); f.element = doms; return f; &#125; var doms = IT('div');doms.a();var bodys = IT('body');bodys.a();console.log( doms.a == bodys.a ); 这个时候，获取到的元素变成构造函数的实例中的一个属性，这样的话，所有获取到的元素就可以访问到构造函数原型中的所有方法，并且指向了同一个内存地址 将代码放到一个闭包函数中，暴露两个接口到外界123456789101112131415161718192021222324(function ()&#123; function Sizzle(selector)&#123; return document.querySelectorAll(selector); &#125; function F()&#123; &#125; F.prototype = &#123; constructor: F, a: function ()&#123; for (var i = 0; i &lt; this.elements.length; i++) &#123; var dom = this.elements[i]; console.log(dom); &#125; &#125; &#125; function IT(selector) &#123; var doms = Sizzle(selector); var f = new F(); f.element = doms; return f; &#125; window.$ = window.jQuery = IT;&#125;)() 避免全局的变量污染 简化代码，清晰第一阶段的逻辑123456789101112131415161718192021;(function ()&#123; function Sizzle(selector)&#123; return document.querySelectorAll(selector); &#125; function F(selector)&#123; this.elements = Sizzle(selector); &#125; F.prototype = &#123; constructor: F, a: function ()&#123; for (var i = 0; i &lt; this.elements.length; i++) &#123; var dom = this.elements[i]; console.log(dom); &#125; &#125; &#125; function IT(selector) &#123; return new F(selector) &#125; window.$ = window.jquery = IT;&#125;)(); 将获取元素的方法放到构造函数的内部，直接在构造函数内部获取到元素，添加到构造函数的属性 第二阶段扩展方法的逻辑123456789101112131415161718192021222324;(function ()&#123; function Sizzle(selector)&#123; return document.querySelectorAll(selector); &#125; function F(selector)&#123; this.elements = Sizzle(selector); &#125; F.prototype = &#123; constructor: F, a: function ()&#123; for (var i = 0; i &lt; this.elements.length; i++) &#123; var dom = this.elements[i]; console.log(dom); &#125; &#125; &#125; F.prototype = IT.prototype; // 让 F 函数的原型指向 IT 函数的原型，这样就可以通过入口函数访问到 F 这个构造函数下的所有方法，并且想要扩展的时候，只需要在入口函数的原型上添加方法即可。 function IT(selector) &#123; return new F(selector) &#125; // IT函数就是入口函数，用来返回一个F实例 window.$ = window.jquery = IT;&#125;)(); 想要扩展方法的时候，需要用插件的形式往jQuery中添加，而不是去修改已经封装好的库。但是外界已经无法访问到F函数，自然就无法向原型添加方法那么索性就直接将操作DOM的方法放在IT函数中，然后让F函数的原型指向IT函数的原型，这样F函数的实例就可以访问到所有的方法 链式编程 关于所谓的链式编程，最简单的描述就是在每个方法的内部再次返回实例即可 12345678910F.prototype = &#123; constructor: F, a: function ()&#123; for (var i = 0; i &lt; this.elements.length; i++) &#123; var dom = this.elements[i]; console.log(dom); &#125; return this; // 返回实例 &#125;&#125; 但是这样的话，会有很多问题出现 并不是所有的方法都需要链式编程，例如CSS方法如果只传入一个参数的话，只需要获取，不需要链式编程 这样的链式编程只能够对一个元素进行链式操作。但是操作的元素不同的话，一条链子就无法实现了。 解决链式编程的问题123456789101112131415161718192021222324(function ()&#123; function Sizzle(selector)&#123; return document.querySeletorAll(selector); &#125; function IT(selector)&#123; return new IT.prototype.F(selector); &#125; IT.prototype = &#123; constructor: IT, F: function (selector)&#123; this.elements = Sizzle(selector); return this; &#125; a: function ()&#123; for(var i = 0; i &lt; this.elements.length; i++) &#123; var dom = this.elements[i]; console.log(dom); &#125; return this; &#125; &#125; IT.prototype.F.prototype = IT.prototype; window.$ = window.jQuery = IT;&#125;)() 将F函数放到入口函数的原型中，这样的话，创建一个实例就可以访问到原型上的F方法，可以继续创建实例。这样的话，就可以继续进行链式编程 将元素以伪数组的方式放到实例中1234567891011121314151617181920212223242526(function ()&#123; function Sizzle(selector)&#123; return document.querySeletorAll(selector); &#125; function IT(selector)&#123; return new IT.prototype.F(selector); &#125; IT.prototype = &#123; constructor: IT, F: function (selector)&#123; [].splice.call(this, 0, this.length) var doms = Sizzle(selector) [].push.apply(this, doms) return this; &#125; a: function ()&#123; for(var i = 0; i &lt; this.length; i++) &#123; var dom = this[i]; console.log(dom); &#125; return this; &#125; &#125; IT.prototype.F.prototype = IT.prototype; window.$ = window.jQuery = IT;&#125;)() 将获取到的元素直接放到实例中，避免产生 this.elements 这个属性，方便用户的遍历。注意的一个小点就是每次添加之前都要对之前添加的进行清空 简化代码，核心完成1234567891011121314151617181920212223242526272829(function ()&#123; var arr = []; var push = arr.push; var splice = arr.splice; function Sizzle(selector)&#123; return document.querySeletorAll(selector); &#125; function jQuery(selector)&#123; return new jQuery.fn.init(selector); &#125; jQuery.fn = jQuery.prototype = &#123; constructor: jQuery, init: function (selector)&#123; splice.call(this, 0, this.length) var doms = Sizzle(selector) push.apply(this, doms) return this; &#125; a: function ()&#123; for(var i = 0; i &lt; this.length; i++) &#123; var dom = this[i]; console.log(dom); &#125; return this; &#125; &#125; jQuery.fn.init.prototype = jQuery.fn; window.$ = window.jQuery = jQuery;&#125;)() 闭包函数，开放两个接口到外界 创建选择器函数 创建一个入口函数，返回入口函数原型中的获取元素的函数 将创建实例的函数定义在入口函数的原型中，直接将获取到的元素保存到创建实例的函数中 将实例函数的原型指向入口函数的原型。能够访问到定义在入口函数的方法 定义两个接口让外界能够进行访问 第三阶段（封装工具方法）封装$.extend()方法123456789101112131415161718jQuery.fn.extend = jQuery.extend = function()&#123; // jQuery.fn.extend 和 jQuery.extend 的方法体是完全一样的 var arg0 = arguments[0]; if ( arguments.length == 1 )&#123; for (var key in arg0)&#123; this[key] = arg0[key]; &#125; return this; &#125; else &#123; for ( var i = 1; i &lt; argument.length; i++ )&#123; var obj = arguments[i]; for (var key in obj)&#123; arg0[key] = obj[key]; &#125; &#125; return arg0; &#125;&#125; 优化版本 12345678910111213141516171819jQuery.fn.extend = jQuery.extend = function()&#123; var target , sources = []; // 定义 target 和 sources 分别表示目标对象和要拷贝的源对象 var arg0 = arguments[0]; if ( arguments.length == 1 )&#123; target = this; sources.push(arg0); &#125; else &#123; target = arg0; push.apply(sources, arguments); &#125; for (var i = 0; i &lt; sources.length; i++) &#123; var source = sources[i]; for (var key in source) &#123; target[key] = source[key]; &#125;&#125; &#125; 实现了 for 循环和 for-in循环的重用 type 方法的实现123456789101112 var toString = Object.prototype.toString; var class2type = &#123;&#125;; var types = "Number String Boolean Math Date Function Array RegExp".split(" "); for (var i = 0; i &lt; types.length; i++) &#123; var type = types[i]; class2type["[object " + type + "]"] = type.toLowerCase();&#125; jQuery.extend(&#123; type: function (data) &#123; return data==null ? data : class2type[toString.call(data)]; &#125; &#125;) 工具类方法12345678910111213141516171819202122 var toString = Object.prototype.toString; var class2type = &#123;&#125;; var types = "Number String Boolean Math Date Function Array RegExp".split(" "); for (var i = 0; i &lt; types.length; i++) &#123; var type = types[i]; class2type["[object " + type + "]"] = type.toLowerCase();&#125; jQuery.extend(&#123; type: function (data)&#123; return data == null ? data : class2type[toString.call(data)]; &#125;, isString: function (str)&#123; return jQuery.type(str) === "string"; &#125;, isFunction: function (fn)&#123; return jQuery.type(str) === "function"; &#125;, isArray: function (arr)&#123; // 判断是不是数组的时候需要注意，ES5 中新增了 Array.isArray() 内置方法，所以应该优先使用这个内置方法，那么就要进行能力检测。 return Array.isArray ? Array.isArray(arr) : jQuery.type(arr) === "array"; &#125; &#125;) 关于jQuery内部函数方法的封装就到这里。完整的代码请参考]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>技术</tag>
      </tags>
  </entry>
</search>
