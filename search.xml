<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[react-native开发环境搭建]]></title>
    <url>%2F2020%2F01%2F06%2Freact-native%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[React Native Android Windows 开发环境搭建 安装依赖必须安装的依赖有：node、react-native-cli、Python2、JDK 和 Android Studio。 下载链接]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Router]]></title>
    <url>%2F2019%2F04%2F16%2FReact-Router%2F</url>
    <content type="text"><![CDATA[React Router 安装1$ npm install react-router-dom 1.单页应用需要进行页面的切换2.通过URL可以定位到页面3.更有语义的组织资源 12345678910&lt;Router&gt; &lt;div&gt; &lt;Link to="/home"&gt;&lt;/Link&gt; &lt;Link to="/login"&gt;&lt;/Link&gt; &lt;/div&gt; &lt;div&gt; &lt;Route path="/home" component=&#123;Home&#125;/&gt; &lt;Route path="/login" component=&#123;Login&#125;/&gt; &lt;/div&gt;&lt;/Router&gt; 这就是一个最简单的用法 三种路由URL 路径 hash 路由内存路由]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux]]></title>
    <url>%2F2019%2F04%2F15%2FRedux%2F</url>
    <content type="text"><![CDATA[Redux 框架 让组件之间的通信变得更加容易 将数据的传递和组件分开 StoreStore 是一个比较抽象的概念 12const store = createStore(reducer)// 参数就是一个 reducer store.getState() 获取数据 store.dispatch(Action) 将产生的 Action 分发给 reducer 来进行处理 store.subscribe(listener) 监听 store 变化 Action描述行为的数据结构，其实就是一个普通的 JavaScript 对象。 1234567891011121314export const ADD_TODO = "ADD_TODO";export const DELETE_TODO = "DELETE_TODO";let nextTodoId=0;export const addTodo = (title, text) =&gt; (&#123; type: ADD_TODO, id: nextTodoId++, title: title, content: text&#125;);export const deleteTodo = (id) =&gt; (&#123; type: DELETE_TODO, id: id&#125;); ActionCreators 其实就是一个生成 Action 的函数上面的 addTodo 和 deleteTodo 就是一个 ActionCreator reducer纯函数，接收 Action 并根据 Action 的值来进行对 state 的处理，返回一个新的 state 12345678910111213141516 function myReducer(state = &#123;&#125;, action) &#123; switch( action.type )&#123; case ADD_TODO: return &#123; ...state, &#123; id: id+1, title: action.title, content: action.text &#125; &#125; break; default: return state; &#125;&#125; 上面的就是一个最简单的 reducer combineReducers()将多个 reducer 进行合并封装 12345678import &#123; combineReducers &#125; from "redux"import todos from "./todos"import counter from "./counter"export default combineReducers(&#123; todos, counter&#125;) bindActionCreators123const boundAddTodo = text =&gt; &#123; dispatch(addTodo(text))&#125; 异步 Action一般用于 发送一个 AJAX 请求 Redux 中间件 Middlewares Redux-thunk截获 Action发出 Action 不可变数据不可变数据不能进行修改，修改它必须进行一层复制，然后在复制的数据上进行修改 性能优化，当数据变化的时候，我们需要通知组件进行更新。这个时候，只需要排查旧的数据和新的数据是不是同一个对象，引用是不是一样，从而决定是否需要更新组件。避免了深层次的数据进行比较，从而提高性能，这也是 Redux 运行的一个基础。 易于调试和跟踪 比较容易看到变化之前的数据和变化之后的数据 易于推测 数据变化前后一定是通过一个 ACtion 触发，那么可以很容易查看到Action 是否有问题 操作不可变数据1234Object.assign(&#123;&#125;, state, &#123;&#125;)// 这种写法性能最高 immutable.js不可变数据 将普通的 JavaScript 数据类型变成 Immutable 类型的不可变数据，操作的主要方法有下面几个 set()设置第一层key、index的值 getIn()获取数据结构中的数据 merge()浅合并，新数据与旧数据对比，旧数据中不存在的属性直接添加，就数据中已存在的属性用新数据中的覆盖 fromJS()将一个js数据转换为 Immutable 类型的数据 toJS()将一个 Immutable 数据转换为JS类型的数据]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 生命周期函数]]></title>
    <url>%2F2019%2F04%2F14%2FReact-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[React 生命周期函数 constructor初始化内部状态，很少使用它来定义方法唯一可以直接修改 state 的地方 使用场景 通过给 this.state 赋值对象来初始化内部 state。 为事件处理函数绑定实例 getDerivedStateFromProps(props, state) [不常用]getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。 此方法适用于罕见的用例，即 state 的值需要取决于 props 来进行初始化。 然而这样是很不好的，这需要时常维护两者的一致性。 因为是取代原来的 componentWillReceiveProps ，所以在每次渲染前都会触发此方法。 使用场景很少一般来说的话，就是初始化表单的默认值，用户一旦改变，那么 state 就来自于用户的输入了 componentDidMount() 只执行一次 该方法会在组件已经被渲染到 DOM 中后立即调用 使用场景 获取外部的资源，数据请求 componentWillUnmount() 组件卸载的时候调用 释放资源 getSnapshotBeforeUpdate(prevProps, prevState)getSnapshotBeforeUpdate() 在最近一次渲染之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 componentDidUpdate()。 可以用来获取 render 之前的DOM状态例如获取页面滚动位置 componentDidUpdate(prevProps, prevState, snapshot)componentDidUpdate() 会在更新后会被立即调用。首次渲染不会执行此方法。 典型场景：页面需要根据 props 的变化来重新获取数据 123456componentDidUpdate(prevProps) &#123; // 典型用法（不要忘记比较 props）： if (this.props.userID !== prevProps.userID) &#123; this.fetchData(this.props.userID); &#125;&#125; componentDidUpdate() 中可以直接调用 setState()，但请注意它必须被包裹在一个条件语件里 shouldComponentUpdate(nextProps, nextState) [不常用]根据 shouldComponentUpdate() 的返回值，判断 React 组件是否需要重新渲染。默认情况下 state 每次发生变化组件都会重新渲染。 当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。返回值默认为 true。返回值为 false 的时候，会阻止 React 渲染。但是，不会阻止子组件的重新渲染。 一般来说可以使用 PureComponentPureComponent 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。 setState 可接收一个函数作为参数，函数的第一个参数是上一个 state，第二个参数是此次更新被应用时的 props 123this.setState((state, props) =&gt; (&#123; counter: state.counter + props.increment&#125;)); 在 React 中另一个不同点是你不能通过返回 false 的方式阻止默认行为。你必须显式的使用 preventDefault 。 你必须谨慎对待 JSX 回调函数中的 this，在 JavaScript 中，class 的方法默认不会绑定 this。如果你忘记绑定 this.handleClick 并把它传入了 onClick，当你调用这个函数的时候 this 的值为 undefined。 1234567891011121314class Toggle extends React.Component &#123; constructor(props) &#123; super(props); // 为了在回调中使用 `this`，这个绑定是必不可少的 this.handleClick = this.handleClick.bind(this); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt;&lt;/button&gt; ); &#125;&#125; 或者可以使用实验性质的public class fields语法， 123456789101112131415class LoggingButton extends React.Component &#123; // 此语法确保 `handleClick` 内的 `this` 已被绑定。 // 注意: 这是 *实验性* 语法。 handleClick = () =&gt; &#123; console.log('this is:', this); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; Click me &lt;/button&gt; ); &#125;&#125; 具体地说，高阶组件是一个获取组件并返回新组件的函数。 1const EnhancedComponent = higherOrderComponent(WrappedComponent); 组件将props转换为UI，而高阶组件将组件转换为另一个组件。 高阶组件高阶组件实际上就是一个纯函数接收一个组件作为参数，返回一个新的组件。 1const EnhancedComponent = higherOrderComponent(WrappedComponent); 比如一个组件需要它的父组件的父组件的父组件的值传递过来使用，但是这个时候只能通过 props 一层一层的往下传递。然后中间的两层实际上是不需要这个值的，这个时候，就适合使用高阶组件。 还有就是一个组件需要另一个组件的功能，这个时候也适合使用高阶组件， 高阶组件只是 React 组件组合使用的一种方法，并不是一个什么特定的 API 12345678910import React from "react"; export default function higherOrderComponent(WrappedComponent) &#123; return class extends React.Component &#123; state = &#123; time: new Date() &#125;; render() &#123; return &lt;WrappedComponent time=&#123;this.state.time&#125; &#123;...this.props&#125; /&gt;; &#125; &#125;; &#125; 上面的就是一个简单的高阶组件。增加了一个 time 属性。本身就是一个纯函数，接收 WrappedComponent 这一个组件作为参数，返回传进来的组件。 使用的时候也很简单在需要使用的组件里，不要导出原有的组件，导出封装后的组件 即可 12345678export class User extends React.Component &#123; render() &#123; return &lt;div&gt; &#123; this.props.time.toLocalString() &#125; &lt;/div&gt;; &#125;&#125;export default higherOrderComponent(User) 函数作为子组件也是一种使用模式，不是 React 的特定 API 12345678910111213class MyComponent extends React.Component &#123; render() &#123; return &lt;React.Fragment&gt; &#123; this.props.childern("Jack") &#125; &lt;/React.Fragment&gt;; &#125;&#125;&lt;MyComponent&gt; &#123;(name) =&gt; &#123; &lt;span&gt;&#123;name&#125;&lt;/span&gt; &#125;&#125;&lt;/MyComponent&gt; 可以由使用 MyComponent 这个组件的组件来决定怎么进行渲染，而不是由 MyComponent 这个组件自身来决定那么就多了很多可扩展性 可以实现很多场景的组件复用 Context API在一个典型的 React 应用中，数据是通过 props 属性自上而下（由父及子）进行传递的，但这种做法对于某些类型的属性而言是极其繁琐的（例如：UI 主题）这些属性是应用程序中许多组件都需要的。Context 提供了一种在组件之间共享此类值的方式。 其实这个 API 很像一个全局的变量，或者数据 Context 主要应用场景在于很多不同层级的组件需要访问同样一些的数据。但是这会使得组件的复用性变差。 这个时候可以考虑将组件自身做为 props 进行传递 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React from "react";const enStrings = &#123; submit: "Submit", cancel: "Cancel"&#125;;const cnStrings = &#123; submit: "提交", cancel: "取消"&#125;;const LocaleContext = React.createContext(enStrings);class LocaleProvider extends React.Component &#123; state = &#123; locale: cnStrings &#125;; render() &#123; return ( &lt;LocaleContext.Provider value=&#123;this.state.locale&#125;&gt; &#123;this.props.children&#125; &lt;/LocaleContext.Provider&gt; ); &#125;&#125;class LocaledButtons extends React.Component &#123; render() &#123; return ( &lt;LocaleContext.Consumer&gt; &#123;locale =&gt; ( &lt;div&gt; &lt;button&gt;&#123;locale.cancel&#125;&lt;/button&gt; &amp;nbsp;&lt;button&gt;&#123;locale.submit&#125;&lt;/button&gt; &lt;/div&gt; )&#125; &lt;/LocaleContext.Consumer&gt; ); &#125;&#125;export default () =&gt; ( &lt;div&gt; &lt;LocaleProvider&gt; &lt;div&gt; &lt;br /&gt; &lt;LocaledButtons /&gt; &lt;/div&gt; &lt;/LocaleProvider&gt; &lt;/div&gt;); bind 放在 constructor 里setState 使用函数，而不是对象指定 key 值shouldComponentUpdate 来确定是否需要更新]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue]]></title>
    <url>%2F2017%2F07%2F01%2FVue%2F</url>
    <content type="text"><![CDATA[简单却不失优雅，小巧而不乏大匠 VueVue 开发必备：vue，vue-router、vue-resource，webpack还有一个就是饿了么团队开发的一个移动端组件库：mint-ui 配置 webpack 一方面帮助我们转换 vue 文件和 ES6 语法，一方面简化开发流程 具体配置信息可以参考另一篇文章Webpack使用 指令v-model 绑定数据模型，和 ng-model 一样，绑定表单元素 v-text 类似于 innerText，解析文本 v-html 类似于 innerHTML，按照 HTML 方式解析，并不推荐，推荐使用组件 v-bind 给一些没有相应指令的属性或者自定义属性绑定数据 语法可简化：v-bind:id=”id” –&gt; :id=”id” v-if 可控制元素的隐藏和显示，值是一个布尔值 true 表示显示（false 直接删除页面元素） v-show 控制元素的隐藏和显示，值是一个布尔值 true 表示显示（false 作用 display为none） v-for 遍历输出 v-for=”(item, index) in items” 可遍历对象 v-on 为元素绑定事件 v-on:click=”事件名称” 可简化语法： @click=”事件名称” tips: 并没有v-class这个指令，但是可以通过v-bind来作用class属性，比较强大的是，可以传一个对象进去，属性名是类名，值是布尔值。用法与ng一样；还可以传一个数组进去，同时作用多个类名；数组内也可以传对象，决定是否作用类名 使用v-for的时候，遍历对象的话，可以写成v-for=&quot;(value, key, index) in items&quot;第一个表示值，第二个表示键，第三个表示索引。 在使用v-for的时候，会出现和ng一样的困扰，ng的解决方法是 track by $index 来确定唯一项，vue的解决方法就是，在循环生成的元素上绑定一个key属性，因为是自定义属性的缘故，所以要用v-bind:key=””来进行绑定，值可以写上索引，也可以根据需求写上后台数据中的id，反正只要是个唯一值就可以了。 组件 tips: 一些小技巧 所有的当前实例中的事件都写在 methods 这个属性中， methods:{&#39;名称&#39;:function(){}} 在 Vue 实例中的data是一个JSON，但是在组件的中的data是一个函数，这是为了让不同的组件实例能够拥有各自的数据。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack使用]]></title>
    <url>%2F2016%2F11%2F20%2FWebpack%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前端资源模块化管理和打包工具 简单示例初始化项目1npm init -y 安装1npm install webpack -g 最简单的就是 webpack app.js bulid.js webpack默认支持es6语法 配置名字是固定的 webpack.config.js，就是一个普通的 node 模块 配置webpack.config.js12345678910111213141516module.exports = &#123; entry: '/app.js', // 打包的入口文件 output: &#123; path: __dirname + '/bin', // 打包文件存储的位置 filename: 'bulid.js' // 打包好的文件名 &#125;, modules: &#123; loaders: [&#123; test: /\.fileType$/, // 设置处理的文件类型，文件后缀名 loader: '' // 设置处理的 loader，中间用!隔开 &#125;] &#125;, plugins: [ ]&#125; 最好加上绝对路径，也就是 __dirname 启动1webpack 会自动执行 webpack.config.js 文件 处理CSS模块安装1npm install style-loader css-loader --save-dev 配置webpack.config.js12345678910111213module.exports = &#123; entry: './app.js', output: &#123; path: __dirname + '/bin', filename: 'bundle.js' &#125;, module: &#123; loaders: [&#123; test: /\.css$/, //配置后缀名 loader: 'style-loader!css-loader' // 顺序不能反，从右往左执行 &#125;] &#125;&#125; style-loader是把css代码插到网页中的style标签中。css-loader处理导入的url 处理 CSS 中的前缀(去除过期的前缀，添加私有前缀)安装1npm install autoprefixer-loader --save-dev 配置webpack.config.js1234loaders: [&#123; test: /\.css$/, loader: 'style-loader!css-loader!autoprefixer-loader'&#125;] 处理 less安装1npm install less-loader less --save-dev 配置webpack.config.js1234loaders: [&#123; test: /\.less$/, loader: 'style-loader!css-loader!autoprefixer-loader!less-loader'&#125;] 处理 scss安装1npm install sass-loader node-sass --save-dev 配置webpack.config.js1234loaders: [&#123; test: /\.scss$/, loader: 'style-loader!css-loader!autoprefixer-loader!sass-loader'&#125;] 处理文件 url-loader file-loader安装1npm install --save-dev url-loader file-loader 配置webpack.config.js1234loaders: [&#123; test: /\.(jpg|png|gif|eot|svg|ttf|woff|otf)$/, loader: 'url-loader?limit=20480'&#125;] 默认会进行编译，那么就限制一下，小于20k的时候再进行转码编译，大于20k就不转码编译但是不编译的话，就会依赖file-loader，必须下载 file-loader 实时打包，浏览器实时自动刷新 webpack-dev-server html-webpack-plugin 注意！！！！如果全局安装了webpack，那么webpack-dev-server是跑不起来的，最简单的解决方法就是本地安装webpack，或者就是配置全局的环境变量 浏览器实时自动刷新 webpack-dev-server 安装1npm install webpack-dev-server --save-dev 运行1webpack-dev-server --inline --hot --open --port 3000 可以在package.json中配置，用npm run的形式跑起来123"script": &#123; "dev" : "webpack-dev-server --inline --hot --open --port 3000"&#125; _注意_：webpack-dev-server 要安装成全局的，才可以在命令行中执行npm run dev 就可以执行 但是，npm run 的这种方式，又必须在本地安装 webpack npm install webpack –save-dev 参数 inline 自动刷新 hot 热加载 open 自动在浏览器中打开 port 指定端口 在内存中生成index.html，并且自动打包编译的文件(app.js中引用的文件) html-webpack-plugin 安装1npm install html-webpack-plugin --save-dev 配置webpack.config.js12345678910111213let htmlWebpackPlugin = require('html-webpack-plugin'); //引入modules: &#123;&#125;,plugins: [ new htmlWebpackPlugin(&#123; title: '页面的标题', // 生成的页面标题 filename: 'index.html', // 生成的文件名称 template: 'template.html' // 模板名称 &#125;)] ES6 转 ES5安装123npm install babel-core babel-loader babel-preset-es2015 --save-dev// 转换.vue文件中的ES6语法npm install babel-plugin-transform-runtime --save-dev 配置webpak.config.js12345678910111213141516171819var webpack = require('webpack') // 引入modules: &#123; loaders: [&#123; test: /\.js$/, exclude: /node_modules/, // 排除指定内容 loader: 'babel-loader' &#125;]&#125;,plugins: [ new webpack.LoaderOptionsPlugin(&#123; options: &#123; babel: &#123; presets: ['es2015'], plugins: ['transform-runtime'] //为了转换.vue中的es6的语法 &#125; &#125; &#125;) ]]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于rem]]></title>
    <url>%2F2016%2F04%2F02%2F%E5%85%B3%E4%BA%8Erem%2F</url>
    <content type="text"><![CDATA[web app 之 rem 关于 remrem是什么？rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到rem大家一定会想起em单位em（font size of the element）是指相对于父元素的字体大小的单位它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。 rem –&gt; 相对于根元素em –&gt; 相对于父元素 em 相对单位 相对于父级元素设置的文字大小进行设置如果没有设置文字大小，就是默认 rem 也是相对单位，但是相对的却是根元素。网页中的根元素指的是html通过设置html的字体大小，就可以控制rem的大小 使用方式举一个简单的例子 123456html &#123; font-size: 20px;&#125;div &#123; width: 1rem; /* 等同于 width: 20px */&#125; 123456html &#123; font-size: 20px;&#125;div &#123; width: 5rem; /* 等同于 width: 20px */&#125; 从上面的两个例子可以看出来，rem的值完全就是根据根元素的字体大小的值来进行改变的那么只要在不同的屏幕中给html设置不同的字体大小便可以更改rem的值 那么，这个时候问题就来了。怎么计算出不同分辨率下font-size的值 首先假设我上面的页面设计稿给我时候是按照640的标准尺寸给我的，（当然这个尺寸肯定不一定是640，可以是320，或者480，又或是375）来看一组表格。 屏幕尺寸 html设置字体 元素宽度 rem 尺寸 页面显示 640 20px 200px 10rem 200px 480 15px 150px 10rem 150px 384 12px 120px 10rem 120px 320 10px 100px 10rem 100px 这个表格的表现出来的数字其实就已经很明显了。 比如：因为设计稿是640的，那么上面宽度为200px的元素，其页面显示的大小应该也是200px；那么在384的页面中，页面显示相同的元素，其宽度应该变成 200*(384/640) px； 384/640 = 0.6，384是640的0.6倍，所以384页面宽度下的font-size也等于640页面宽度下的0.6倍，这时384的font-size就等于12px。在不同设备的宽度计算方式以此类推。 总结一下rem 这个东西对于移动端开发来说简直就是一个福音，因为在传统的移动端开发来说的话，各种方式都会有一定的弊端 流式布局的话通过百分比来定义宽度，但是高度的话往往是用px来定住，这个时候在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度还是和原来一样，十分不协调。 固定页面宽度的做法，虽然一定程度上解决了上面高度定死，宽度拉长的问题，但是在大屏幕的手机下，两边都是留白，不美观，并且在大屏幕下页面会特别小。 响应式的做法只能是针对小型的门户或者博客类网站会用，因为大网站用响应式的话工作量会特别大，并且难以维护。 设置viewport进行缩放的话，简单，粗暴，高效，以一个较小的屏幕为基准，缩放到一定程度。基本上可以满足适配的问题。 rem则是可以做到全设备，全尺寸的等比例适配。 根据屏幕宽度的不同，用js判断或者使用css3中的媒体查询设定不同屏幕宽度下根元素的字体大小。做到全设备的自适应。 目前比较流行的解决方案可能就是淘宝的lib-flexible]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery插件开发]]></title>
    <url>%2F2016%2F03%2F15%2FjQuery%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[jQuery的插件开发流程 jQuery 插件开发根据《jQuery高级编程》的描述，jQuery插件开发方式主要有三种： 通过$.extend()来扩展jQuery通过$.fn 向jQuery添加新的方法通过$.widget()应用jQuery UI的部件工厂方式创建 第三种方式我并不是很了解，所以这里只介绍前两种方法 $.extend()使用这种方式来进行插件开发很简单，因为这就是相当于仅仅是在jQuery命名空间或者理解成jQuery身上添加了一个静态方法而已，直接通过$符号就可以调用。 123456$.extend(&#123; sayHi: function()&#123; console.log('Hello World!'); &#125;&#125;)$.sayHi(); 上面代码中，通过$.extend()向jQuery添加了一个sayHi函数，然后通过$直接调用。到此你可以认为我们已经完成了一个简单的jQuery插件了。 但这种方式无法利用jQuery强大的选择器带来的便利，要处理DOM元素以及将插件更好地运用于所选择的元素身上，还是需要使用第二种开发方式。我们使用的插件也大多是通过此种方式开发。 $.fn.extend()123$.fn.pluginName = function ()&#123; // 插件逻辑代码&#125; 基本上就是往$.fn上面添加一个方法，名字是我们的插件名称。然后我们的插件代码在这个方法里面展开。 在插件名字定义的这个函数内部，this指代的是我们在调用该插件时，用jQuery选择器选中的元素，一般是一个jQuery类型的集合。 支持链式调用123456$.fn.myPlugin = function() &#123; this.css('color', 'red'); return this.each(function() &#123; $(this).append(' ' + $(this).attr('href')); &#125;))&#125; 想要让开发的插件支持链式调用的话，其实很简单，只需要最后 return 一下即可 插件接收参数1234567891011$.fn.myPlugin = function(options)&#123; var defaults = &#123; 'color': 'red', 'fontSize': '12px' &#125;; var settings = $.extend(&#123;&#125;, defaults, options); return this.css(&#123; 'color': settings.color, 'fontSize': settings.fontSize &#125;);&#125; 一般来说，想要望插件里面传递自定义的参数，用的就是这种方法。defaluts 表示的是默认的参数，当用户没有传递向对应的自定义参数的时候，就使用默认的settings 的作用是将参数中的每一项拷贝到这个对象中，进行处理 面向对象的方式来开发插件前面的方式其实已经可以写出一个健壮灵活的插件了，但是要是写一个复杂的插件的话，代码量大，代码的组织就是一个问题，使用面向对象的方式来进行开发，会更灵活，可维护 12345678910111213141516171819202122var Beautifier = function(ele, opt) &#123; this.$element = ele, this.defaults = &#123; 'color': 'red', 'fontSize': '12px', 'textDecoration':'none' &#125;, this.options = $.extend(&#123;&#125;, this.defaults, opt)&#125;Beautifier.prototype = &#123; beautify: function() &#123; return this.$element.css(&#123; 'color': this.options.color, 'fontSize': this.options.fontSize, 'textDecoration': this.options.textDecoration &#125;); &#125;&#125;$.fn.myPlugin = function(options) &#123; var beautifier = new Beautifier(this, options); return beautifier.beautify();&#125; 将需要的重要变量定义到对象的属性上，函数变成对象的方法，当我们需要的时候通过对象来获取一来方便管理，二来不会影响外部命名空间，因为所有这些变量名还有方法名都是在对象内部。 闭包函数，防止命名冲突123456789101112131415161718192021222324;(function($, window, document, undefined) &#123; var Beautifier = function(ele, opt) &#123; this.$element = ele, this.defaults = &#123; 'color': 'red', 'fontSize': '12px', 'textDecoration': 'none' &#125;, this.options = $.extend(&#123;&#125;, this.defaults, opt) &#125; Beautifier.prototype = &#123; beautify: function() &#123; return this.$element.css(&#123; 'color': this.options.color, 'fontSize': this.options.fontSize, 'textDecoration': this.options.textDecoration &#125;); &#125; &#125; $.fn.myPlugin = function(options) &#123; var beautifier = new Beautifier(this, options); return beautifier.beautify(); &#125;&#125;)(jQuery, window, document); 这就是一个完整的插件开发流程。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery源码简析]]></title>
    <url>%2F2016%2F03%2F12%2FjQuery%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[对jQ的源码做了一些了解，在这里简单实现一下。 关于jQuery不可否认，jQuery的重要性，使用频率堪称前端程序员之最。正像作者所提出的口号一样：“Write Less, Do More”，写的更少，做的更多。 独特的链式语法，高效灵活的CSS选择器，便捷的插件扩展机制，强大的兼容性 tips：关于jQuery中的选择器引擎，是jQuery作者另外写的一个选择器引擎，这里不多做介绍，本篇文章利用H5新增的querySelectorAll来模拟jQuery中的Sizzle选择器引擎。 第一阶段模拟选择器引擎123function Sizzle(selector)&#123; return document.querySelectorAll(selector);&#125; Sizzle函数只是用来获取元素的方法，那么为了不影响其独立性和干净，所有方法和属性就不应该扔在Sizzle函数中。 定义函数，在函数内部调用Sizzle函数来获取到元素1234567891011121314151617 function Sizzle(selector)&#123; return document.querySelectorAll(selector); &#125; function IT(selector) &#123; var doms = Sizzle(selector); doms.a = function ()&#123; for (var i = 0; i &lt; this.length; i++) &#123; var dom = this[i]; console.log(dom); &#125; &#125; return doms; &#125; var doms = IT('div');doms.a(); 这样的话，会出现另一个问题，当获取多个页面元素的时候，因为a方法是定义在DOM元素下面的，那么获取多个元素的时候，就会创建多个a方法的内存空间，从而影响性能 将方法放在原型上，解决多个元素的时候，创建多个内存空间的问题123456789101112131415function Sizzle(selector)&#123; return document.querySelectorAll(selector);&#125;NodeList.prototype.a = function()&#123; for (var i = 0; i &lt; this.length; i++) &#123; var dom = this[i]; console.log(dom);&#125;&#125;function IT(selector)&#123; var doms = Sizzle(selector); return doms;&#125; doms是NodeList的实例。那么doms对象指向的原型就应该是NodeList函数的原型 这个时候，访问原型上的方法就可以避免创建多个内存空间的问题 但是NodeList是一个内置的对象，不应该进行污染，那么就自定义一个对象，将所有的方法放在自定义对象中 将方法放在自定义对象中12345678910111213141516function Sizzle(selector)&#123; return document.querySelectorAll(selector);&#125;function IT(selector) &#123; var doms = Sizzle(selector); var obj = &#123; a: function ()&#123; for (var i = 0; i &lt; this.length; i++) &#123; var dom = this[i]; console.log(dom); &#125; &#125; &#125; obj.elements = doms; return obj;&#125; 创建一个对象，让获取到的元素成为这个对象的一个属性，那么这些元素就可以访问到这个对象上面的所有方法，并且没有污染到内置的对象。 但是，这个时候，又回到了以前的一个问题，，每次调用 IT 函数的时候，又会创建单独的对象，方法就又指向了不同的内存空间。影响性能 将方法放在自定义的构造函数中123456789101112131415161718192021222324252627 function Sizzle(selector)&#123; return document.querySelectorAll(selector); &#125; function F()&#123; &#125; F.prototype = &#123; constructor: F, a: function ()&#123; for (var i = 0; i &lt; this.elements.length; i++) &#123; var dom = this.elements[i]; console.log(dom); &#125; &#125; &#125; function IT(selector) &#123; var doms = Sizzle(selector); var f = new F(); f.element = doms; return f; &#125; var doms = IT('div');doms.a();var bodys = IT('body');bodys.a();console.log( doms.a == bodys.a ); 这个时候，获取到的元素变成构造函数的实例中的一个属性，这样的话，所有获取到的元素就可以访问到构造函数原型中的所有方法，并且指向了同一个内存地址 将代码放到一个闭包函数中，暴露两个接口到外界123456789101112131415161718192021222324(function ()&#123; function Sizzle(selector)&#123; return document.querySelectorAll(selector); &#125; function F()&#123; &#125; F.prototype = &#123; constructor: F, a: function ()&#123; for (var i = 0; i &lt; this.elements.length; i++) &#123; var dom = this.elements[i]; console.log(dom); &#125; &#125; &#125; function IT(selector) &#123; var doms = Sizzle(selector); var f = new F(); f.element = doms; return f; &#125; window.$ = window.jQuery = IT;&#125;)() 避免全局的变量污染 简化代码，清晰第一阶段的逻辑123456789101112131415161718192021;(function ()&#123; function Sizzle(selector)&#123; return document.querySelectorAll(selector); &#125; function F(selector)&#123; this.elements = Sizzle(selector); &#125; F.prototype = &#123; constructor: F, a: function ()&#123; for (var i = 0; i &lt; this.elements.length; i++) &#123; var dom = this.elements[i]; console.log(dom); &#125; &#125; &#125; function IT(selector) &#123; return new F(selector) &#125; window.$ = window.jquery = IT;&#125;)(); 将获取元素的方法放到构造函数的内部，直接在构造函数内部获取到元素，添加到构造函数的属性 第二阶段扩展方法的逻辑123456789101112131415161718192021222324;(function ()&#123; function Sizzle(selector)&#123; return document.querySelectorAll(selector); &#125; function F(selector)&#123; this.elements = Sizzle(selector); &#125; F.prototype = &#123; constructor: F, a: function ()&#123; for (var i = 0; i &lt; this.elements.length; i++) &#123; var dom = this.elements[i]; console.log(dom); &#125; &#125; &#125; F.prototype = IT.prototype; // 让 F 函数的原型指向 IT 函数的原型，这样就可以通过入口函数访问到 F 这个构造函数下的所有方法，并且想要扩展的时候，只需要在入口函数的原型上添加方法即可。 function IT(selector) &#123; return new F(selector) &#125; // IT函数就是入口函数，用来返回一个F实例 window.$ = window.jquery = IT;&#125;)(); 想要扩展方法的时候，需要用插件的形式往jQuery中添加，而不是去修改已经封装好的库。但是外界已经无法访问到F函数，自然就无法向原型添加方法那么索性就直接将操作DOM的方法放在IT函数中，然后让F函数的原型指向IT函数的原型，这样F函数的实例就可以访问到所有的方法 链式编程 关于所谓的链式编程，最简单的描述就是在每个方法的内部再次返回实例即可 12345678910F.prototype = &#123; constructor: F, a: function ()&#123; for (var i = 0; i &lt; this.elements.length; i++) &#123; var dom = this.elements[i]; console.log(dom); &#125; return this; // 返回实例 &#125;&#125; 但是这样的话，会有很多问题出现 并不是所有的方法都需要链式编程，例如CSS方法如果只传入一个参数的话，只需要获取，不需要链式编程 这样的链式编程只能够对一个元素进行链式操作。但是操作的元素不同的话，一条链子就无法实现了。 解决链式编程的问题123456789101112131415161718192021222324(function ()&#123; function Sizzle(selector)&#123; return document.querySeletorAll(selector); &#125; function IT(selector)&#123; return new IT.prototype.F(selector); &#125; IT.prototype = &#123; constructor: IT, F: function (selector)&#123; this.elements = Sizzle(selector); return this; &#125; a: function ()&#123; for(var i = 0; i &lt; this.elements.length; i++) &#123; var dom = this.elements[i]; console.log(dom); &#125; return this; &#125; &#125; IT.prototype.F.prototype = IT.prototype; window.$ = window.jQuery = IT;&#125;)() 将F函数放到入口函数的原型中，这样的话，创建一个实例就可以访问到原型上的F方法，可以继续创建实例。这样的话，就可以继续进行链式编程 将元素以伪数组的方式放到实例中1234567891011121314151617181920212223242526(function ()&#123; function Sizzle(selector)&#123; return document.querySeletorAll(selector); &#125; function IT(selector)&#123; return new IT.prototype.F(selector); &#125; IT.prototype = &#123; constructor: IT, F: function (selector)&#123; [].splice.call(this, 0, this.length) var doms = Sizzle(selector) [].push.apply(this, doms) return this; &#125; a: function ()&#123; for(var i = 0; i &lt; this.length; i++) &#123; var dom = this[i]; console.log(dom); &#125; return this; &#125; &#125; IT.prototype.F.prototype = IT.prototype; window.$ = window.jQuery = IT;&#125;)() 将获取到的元素直接放到实例中，避免产生 this.elements 这个属性，方便用户的遍历。注意的一个小点就是每次添加之前都要对之前添加的进行清空 简化代码，核心完成1234567891011121314151617181920212223242526272829(function ()&#123; var arr = []; var push = arr.push; var splice = arr.splice; function Sizzle(selector)&#123; return document.querySeletorAll(selector); &#125; function jQuery(selector)&#123; return new jQuery.fn.init(selector); &#125; jQuery.fn = jQuery.prototype = &#123; constructor: jQuery, init: function (selector)&#123; splice.call(this, 0, this.length) var doms = Sizzle(selector) push.apply(this, doms) return this; &#125; a: function ()&#123; for(var i = 0; i &lt; this.length; i++) &#123; var dom = this[i]; console.log(dom); &#125; return this; &#125; &#125; jQuery.fn.init.prototype = jQuery.fn; window.$ = window.jQuery = jQuery;&#125;)() 闭包函数，开放两个接口到外界 创建选择器函数 创建一个入口函数，返回入口函数原型中的获取元素的函数 将创建实例的函数定义在入口函数的原型中，直接将获取到的元素保存到创建实例的函数中 将实例函数的原型指向入口函数的原型。能够访问到定义在入口函数的方法 定义两个接口让外界能够进行访问 第三阶段（封装工具方法）封装$.extend()方法123456789101112131415161718jQuery.fn.extend = jQuery.extend = function()&#123; // jQuery.fn.extend 和 jQuery.extend 的方法体是完全一样的 var arg0 = arguments[0]; if ( arguments.length == 1 )&#123; for (var key in arg0)&#123; this[key] = arg0[key]; &#125; return this; &#125; else &#123; for ( var i = 1; i &lt; argument.length; i++ )&#123; var obj = arguments[i]; for (var key in obj)&#123; arg0[key] = obj[key]; &#125; &#125; return arg0; &#125;&#125; 优化版本 12345678910111213141516171819jQuery.fn.extend = jQuery.extend = function()&#123; var target , sources = []; // 定义 target 和 sources 分别表示目标对象和要拷贝的源对象 var arg0 = arguments[0]; if ( arguments.length == 1 )&#123; target = this; sources.push(arg0); &#125; else &#123; target = arg0; push.apply(sources, arguments); &#125; for (var i = 0; i &lt; sources.length; i++) &#123; var source = sources[i]; for (var key in source) &#123; target[key] = source[key]; &#125;&#125; &#125; 实现了 for 循环和 for-in循环的重用 type 方法的实现123456789101112 var toString = Object.prototype.toString; var class2type = &#123;&#125;; var types = "Number String Boolean Math Date Function Array RegExp".split(" "); for (var i = 0; i &lt; types.length; i++) &#123; var type = types[i]; class2type["[object " + type + "]"] = type.toLowerCase();&#125; jQuery.extend(&#123; type: function (data) &#123; return data==null ? data : class2type[toString.call(data)]; &#125; &#125;) 工具类方法12345678910111213141516171819202122 var toString = Object.prototype.toString; var class2type = &#123;&#125;; var types = "Number String Boolean Math Date Function Array RegExp".split(" "); for (var i = 0; i &lt; types.length; i++) &#123; var type = types[i]; class2type["[object " + type + "]"] = type.toLowerCase();&#125; jQuery.extend(&#123; type: function (data)&#123; return data == null ? data : class2type[toString.call(data)]; &#125;, isString: function (str)&#123; return jQuery.type(str) === "string"; &#125;, isFunction: function (fn)&#123; return jQuery.type(str) === "function"; &#125;, isArray: function (arr)&#123; // 判断是不是数组的时候需要注意，ES5 中新增了 Array.isArray() 内置方法，所以应该优先使用这个内置方法，那么就要进行能力检测。 return Array.isArray ? Array.isArray(arr) : jQuery.type(arr) === "array"; &#125; &#125;) 大致原理大概是这样，这里就写到这，具体源码可参考官网。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
</search>
